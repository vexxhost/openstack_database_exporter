// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package cinder

import (
	"context"
	"database/sql"
)

const GetAllServices = `-- name: GetAllServices :many
SELECT
    uuid,
    host,
    ` + "`" + `binary` + "`" + ` as service,
    CASE
        WHEN disabled = 1 THEN 'disabled'
        ELSE 'enabled'
    END as admin_state,
    availability_zone as zone,
    disabled_reason,
    CASE
        WHEN TIMESTAMPDIFF (SECOND, updated_at, NOW()) <= 60 THEN 1
        ELSE 0
    END as state
FROM
    services
WHERE
    deleted = 0
`

type GetAllServicesRow struct {
	Uuid           sql.NullString
	Host           sql.NullString
	Service        sql.NullString
	AdminState     string
	Zone           sql.NullString
	DisabledReason sql.NullString
	State          int32
}

func (q *Queries) GetAllServices(ctx context.Context) ([]GetAllServicesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetAllServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllServicesRow
	for rows.Next() {
		var i GetAllServicesRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Host,
			&i.Service,
			&i.AdminState,
			&i.Zone,
			&i.DisabledReason,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAllVolumes = `-- name: GetAllVolumes :many
SELECT
    v.id,
    v.display_name as name,
    v.size,
    v.status,
    v.availability_zone,
    v.bootable,
    v.project_id,
    v.user_id,
    vt.name as volume_type,
    va.instance_uuid as server_id
FROM
    volumes v USE INDEX (volumes_service_uuid_idx)
    LEFT JOIN volume_types vt ON v.volume_type_id = vt.id
    LEFT JOIN volume_attachment va ON v.id = va.volume_id AND va.deleted = 0
WHERE
    (v.service_uuid IS NULL OR v.service_uuid IS NOT NULL)
    AND v.deleted = 0
`

type GetAllVolumesRow struct {
	ID               string
	Name             sql.NullString
	Size             sql.NullInt32
	Status           sql.NullString
	AvailabilityZone sql.NullString
	Bootable         sql.NullBool
	ProjectID        sql.NullString
	UserID           sql.NullString
	VolumeType       sql.NullString
	ServerID         sql.NullString
}

func (q *Queries) GetAllVolumes(ctx context.Context) ([]GetAllVolumesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetAllVolumes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllVolumesRow
	for rows.Next() {
		var i GetAllVolumesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Status,
			&i.AvailabilityZone,
			&i.Bootable,
			&i.ProjectID,
			&i.UserID,
			&i.VolumeType,
			&i.ServerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetProjectQuotaLimits = `-- name: GetProjectQuotaLimits :many
SELECT
    q.project_id,
    q.resource,
    q.hard_limit,
    COALESCE(qu.in_use, 0) as in_use
FROM
    quotas q
    LEFT JOIN quota_usages qu ON q.project_id = qu.project_id
        AND q.resource = qu.resource
        AND qu.deleted = 0
WHERE
    q.deleted = 0
    AND q.resource IN ('gigabytes', 'backup_gigabytes')
`

type GetProjectQuotaLimitsRow struct {
	ProjectID sql.NullString
	Resource  string
	HardLimit sql.NullInt32
	InUse     int32
}

func (q *Queries) GetProjectQuotaLimits(ctx context.Context) ([]GetProjectQuotaLimitsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetProjectQuotaLimits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectQuotaLimitsRow
	for rows.Next() {
		var i GetProjectQuotaLimitsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Resource,
			&i.HardLimit,
			&i.InUse,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSnapshotCount = `-- name: GetSnapshotCount :one
SELECT
    COUNT(*) as count
FROM
    snapshots
WHERE
    deleted = 0
`

func (q *Queries) GetSnapshotCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetSnapshotCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}
