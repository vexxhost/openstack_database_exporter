// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package nova_api

import (
	"context"
	"database/sql"
)

const GetAggregateHosts = `-- name: GetAggregateHosts :many
SELECT 
    ah.id,
    ah.host,
    ah.aggregate_id,
    a.name as aggregate_name,
    a.uuid as aggregate_uuid
FROM aggregate_hosts ah
JOIN aggregates a ON ah.aggregate_id = a.id
`

type GetAggregateHostsRow struct {
	ID            int32
	Host          sql.NullString
	AggregateID   int32
	AggregateName sql.NullString
	AggregateUuid sql.NullString
}

func (q *Queries) GetAggregateHosts(ctx context.Context) ([]GetAggregateHostsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetAggregateHosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggregateHostsRow
	for rows.Next() {
		var i GetAggregateHostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Host,
			&i.AggregateID,
			&i.AggregateName,
			&i.AggregateUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAggregates = `-- name: GetAggregates :many
SELECT 
    id,
    uuid,
    name,
    created_at,
    updated_at
FROM aggregates
`

type GetAggregatesRow struct {
	ID        int32
	Uuid      sql.NullString
	Name      sql.NullString
	CreatedAt sql.NullTime
	UpdatedAt sql.NullTime
}

func (q *Queries) GetAggregates(ctx context.Context) ([]GetAggregatesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetAggregates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggregatesRow
	for rows.Next() {
		var i GetAggregatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetFlavors = `-- name: GetFlavors :many
SELECT 
    id,
    flavorid,
    name,
    vcpus,
    memory_mb,
    root_gb,
    ephemeral_gb,
    swap,
    rxtx_factor,
    disabled,
    is_public
FROM flavors
`

type GetFlavorsRow struct {
	ID          int32
	Flavorid    string
	Name        string
	Vcpus       int32
	MemoryMb    int32
	RootGb      sql.NullInt32
	EphemeralGb sql.NullInt32
	Swap        int32
	RxtxFactor  sql.NullFloat64
	Disabled    sql.NullBool
	IsPublic    sql.NullBool
}

func (q *Queries) GetFlavors(ctx context.Context) ([]GetFlavorsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetFlavors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlavorsRow
	for rows.Next() {
		var i GetFlavorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Flavorid,
			&i.Name,
			&i.Vcpus,
			&i.MemoryMb,
			&i.RootGb,
			&i.EphemeralGb,
			&i.Swap,
			&i.RxtxFactor,
			&i.Disabled,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetQuotaUsages = `-- name: GetQuotaUsages :many
SELECT 
    id,
    project_id,
    resource,
    in_use,
    reserved,
    until_refresh,
    user_id
FROM quota_usages
`

type GetQuotaUsagesRow struct {
	ID           int32
	ProjectID    sql.NullString
	Resource     string
	InUse        int32
	Reserved     int32
	UntilRefresh sql.NullInt32
	UserID       sql.NullString
}

func (q *Queries) GetQuotaUsages(ctx context.Context) ([]GetQuotaUsagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetQuotaUsages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuotaUsagesRow
	for rows.Next() {
		var i GetQuotaUsagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Resource,
			&i.InUse,
			&i.Reserved,
			&i.UntilRefresh,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetQuotas = `-- name: GetQuotas :many
SELECT 
    id,
    project_id,
    resource,
    hard_limit
FROM quotas
`

type GetQuotasRow struct {
	ID        int32
	ProjectID sql.NullString
	Resource  string
	HardLimit sql.NullInt32
}

func (q *Queries) GetQuotas(ctx context.Context) ([]GetQuotasRow, error) {
	rows, err := q.db.QueryContext(ctx, GetQuotas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuotasRow
	for rows.Next() {
		var i GetQuotasRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Resource,
			&i.HardLimit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
