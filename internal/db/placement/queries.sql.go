// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package placement

import (
	"context"
	"database/sql"
)

const GetResourceMetrics = `-- name: GetResourceMetrics :many
SELECT 
    rp.name as hostname,
    rc.name as resource_type,
    i.total,
    i.allocation_ratio,
    i.reserved,
    COALESCE(SUM(a.used), 0) as used
FROM resource_providers rp
JOIN inventories i ON rp.id = i.resource_provider_id
JOIN resource_classes rc ON i.resource_class_id = rc.id
LEFT JOIN allocations a ON rp.id = a.resource_provider_id AND rc.id = a.resource_class_id
GROUP BY rp.id, rp.name, rc.id, rc.name, i.total, i.allocation_ratio, i.reserved
ORDER BY rp.name, rc.name
`

type GetResourceMetricsRow struct {
	Hostname        sql.NullString
	ResourceType    string
	Total           int32
	AllocationRatio string
	Reserved        int32
	Used            interface{}
}

// This is the main query that provides data for all four metrics:
// - resource_total: inventory total
// - resource_allocation_ratio: inventory allocation_ratio
// - resource_reserved: inventory reserved
// - resource_usage: sum of allocations per resource provider + class
func (q *Queries) GetResourceMetrics(ctx context.Context) ([]GetResourceMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetResourceMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceMetricsRow
	for rows.Next() {
		var i GetResourceMetricsRow
		if err := rows.Scan(
			&i.Hostname,
			&i.ResourceType,
			&i.Total,
			&i.AllocationRatio,
			&i.Reserved,
			&i.Used,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
