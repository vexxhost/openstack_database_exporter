// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package placement

import (
	"context"
	"database/sql"
)

const GetAllocationsByProject = `-- name: GetAllocationsByProject :many
SELECT 
    p.external_id as project_id,
    rc.name as resource_type,
    COALESCE(SUM(a.used), 0) as used
FROM projects p
LEFT JOIN consumers c ON p.id = c.project_id
LEFT JOIN allocations a ON c.uuid = a.consumer_id
LEFT JOIN resource_classes rc ON a.resource_class_id = rc.id
WHERE rc.name IS NOT NULL
GROUP BY p.external_id, rc.name
ORDER BY p.external_id, rc.name
`

type GetAllocationsByProjectRow struct {
	ProjectID    string
	ResourceType sql.NullString
	Used         interface{}
}

// Get resource usage by project for Nova quota calculations
func (q *Queries) GetAllocationsByProject(ctx context.Context) ([]GetAllocationsByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, GetAllocationsByProject)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllocationsByProjectRow
	for rows.Next() {
		var i GetAllocationsByProjectRow
		if err := rows.Scan(&i.ProjectID, &i.ResourceType, &i.Used); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetConsumers = `-- name: GetConsumers :many
SELECT 
    c.id,
    c.uuid,
    c.generation,
    p.external_id as project_id,
    u.external_id as user_id
FROM consumers c
JOIN projects p ON c.project_id = p.id
JOIN users u ON c.user_id = u.id
ORDER BY c.created_at DESC
`

type GetConsumersRow struct {
	ID         int32
	Uuid       string
	Generation int32
	ProjectID  string
	UserID     string
}

// Get consumer information for allocation tracking
func (q *Queries) GetConsumers(ctx context.Context) ([]GetConsumersRow, error) {
	rows, err := q.db.QueryContext(ctx, GetConsumers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConsumersRow
	for rows.Next() {
		var i GetConsumersRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Generation,
			&i.ProjectID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetResourceClasses = `-- name: GetResourceClasses :many
SELECT 
    id,
    name
FROM resource_classes
ORDER BY name
`

type GetResourceClassesRow struct {
	ID   int32
	Name string
}

// Get all resource classes for reference
func (q *Queries) GetResourceClasses(ctx context.Context) ([]GetResourceClassesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetResourceClasses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceClassesRow
	for rows.Next() {
		var i GetResourceClassesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetResourceMetrics = `-- name: GetResourceMetrics :many
SELECT 
    rp.name as hostname,
    rc.name as resource_type,
    i.total,
    i.allocation_ratio,
    i.reserved,
    COALESCE(SUM(a.used), 0) as used
FROM resource_providers rp
JOIN inventories i ON rp.id = i.resource_provider_id
JOIN resource_classes rc ON i.resource_class_id = rc.id
LEFT JOIN allocations a ON rp.id = a.resource_provider_id AND rc.id = a.resource_class_id
GROUP BY rp.id, rp.name, rc.id, rc.name, i.total, i.allocation_ratio, i.reserved
ORDER BY rp.name, rc.name
`

type GetResourceMetricsRow struct {
	Hostname        sql.NullString
	ResourceType    string
	Total           int32
	AllocationRatio string
	Reserved        int32
	Used            interface{}
}

// This is the main query that provides data for all four metrics:
// - resource_total: inventory total
// - resource_allocation_ratio: inventory allocation_ratio
// - resource_reserved: inventory reserved
// - resource_usage: sum of allocations per resource provider + class
func (q *Queries) GetResourceMetrics(ctx context.Context) ([]GetResourceMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetResourceMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourceMetricsRow
	for rows.Next() {
		var i GetResourceMetricsRow
		if err := rows.Scan(
			&i.Hostname,
			&i.ResourceType,
			&i.Total,
			&i.AllocationRatio,
			&i.Reserved,
			&i.Used,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
